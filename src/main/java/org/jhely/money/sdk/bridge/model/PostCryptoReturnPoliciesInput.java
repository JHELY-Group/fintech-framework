/*
 * Bridge API
 * APIs to move into, out of, and between any form of a dollar
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.jhely.money.sdk.bridge.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * PostCryptoReturnPoliciesInput
 */
@JsonPropertyOrder({
  PostCryptoReturnPoliciesInput.JSON_PROPERTY_REFUND_DESTINATION_ADDRESS,
  PostCryptoReturnPoliciesInput.JSON_PROPERTY_REFUND_DESTINATION_BLOCKCHAIN_MEMO,
  PostCryptoReturnPoliciesInput.JSON_PROPERTY_REFUND_DESTINATION_CHAIN,
  PostCryptoReturnPoliciesInput.JSON_PROPERTY_REFUND_DESTINATION_CURRENCY,
  PostCryptoReturnPoliciesInput.JSON_PROPERTY_STRATEGY
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
public class PostCryptoReturnPoliciesInput {
  public static final String JSON_PROPERTY_REFUND_DESTINATION_ADDRESS = "refund_destination_address";
  @jakarta.annotation.Nullable
  private String refundDestinationAddress;

  public static final String JSON_PROPERTY_REFUND_DESTINATION_BLOCKCHAIN_MEMO = "refund_destination_blockchain_memo";
  @jakarta.annotation.Nullable
  private String refundDestinationBlockchainMemo;

  public static final String JSON_PROPERTY_REFUND_DESTINATION_CHAIN = "refund_destination_chain";
  @jakarta.annotation.Nullable
  private String refundDestinationChain;

  public static final String JSON_PROPERTY_REFUND_DESTINATION_CURRENCY = "refund_destination_currency";
  @jakarta.annotation.Nullable
  private String refundDestinationCurrency;

  public static final String JSON_PROPERTY_STRATEGY = "strategy";
  @jakarta.annotation.Nullable
  private String strategy;

  public PostCryptoReturnPoliciesInput() {
  }

  public PostCryptoReturnPoliciesInput refundDestinationAddress(@jakarta.annotation.Nullable String refundDestinationAddress) {
    
    this.refundDestinationAddress = refundDestinationAddress;
    return this;
  }

  /**
   * The address to which the refund will be sent. Required if the strategy is &#x60;static_address&#x60;, but must be unset if the strategy is &#x60;refund_to_sender&#x60;.
   * @return refundDestinationAddress
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_REFUND_DESTINATION_ADDRESS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRefundDestinationAddress() {
    return refundDestinationAddress;
  }


  @JsonProperty(value = JSON_PROPERTY_REFUND_DESTINATION_ADDRESS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRefundDestinationAddress(@jakarta.annotation.Nullable String refundDestinationAddress) {
    this.refundDestinationAddress = refundDestinationAddress;
  }

  public PostCryptoReturnPoliciesInput refundDestinationBlockchainMemo(@jakarta.annotation.Nullable String refundDestinationBlockchainMemo) {
    
    this.refundDestinationBlockchainMemo = refundDestinationBlockchainMemo;
    return this;
  }

  /**
   * The memo to include with the refund transaction. Must be unset if the strategy is &#x60;refund_to_sender&#x60;.
   * @return refundDestinationBlockchainMemo
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_REFUND_DESTINATION_BLOCKCHAIN_MEMO, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRefundDestinationBlockchainMemo() {
    return refundDestinationBlockchainMemo;
  }


  @JsonProperty(value = JSON_PROPERTY_REFUND_DESTINATION_BLOCKCHAIN_MEMO, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRefundDestinationBlockchainMemo(@jakarta.annotation.Nullable String refundDestinationBlockchainMemo) {
    this.refundDestinationBlockchainMemo = refundDestinationBlockchainMemo;
  }

  public PostCryptoReturnPoliciesInput refundDestinationChain(@jakarta.annotation.Nullable String refundDestinationChain) {
    
    this.refundDestinationChain = refundDestinationChain;
    return this;
  }

  /**
   * The blockchain on which the refund will be sent. Required if the strategy is &#x60;static_address&#x60;, but must be unset if the strategy is &#x60;refund_to_sender&#x60;.
   * @return refundDestinationChain
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_REFUND_DESTINATION_CHAIN, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRefundDestinationChain() {
    return refundDestinationChain;
  }


  @JsonProperty(value = JSON_PROPERTY_REFUND_DESTINATION_CHAIN, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRefundDestinationChain(@jakarta.annotation.Nullable String refundDestinationChain) {
    this.refundDestinationChain = refundDestinationChain;
  }

  public PostCryptoReturnPoliciesInput refundDestinationCurrency(@jakarta.annotation.Nullable String refundDestinationCurrency) {
    
    this.refundDestinationCurrency = refundDestinationCurrency;
    return this;
  }

  /**
   * The currency to which the refund will be sent. Required if the strategy is &#x60;static_address&#x60;, but must be unset if the strategy is &#x60;refund_to_sender&#x60;.
   * @return refundDestinationCurrency
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_REFUND_DESTINATION_CURRENCY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRefundDestinationCurrency() {
    return refundDestinationCurrency;
  }


  @JsonProperty(value = JSON_PROPERTY_REFUND_DESTINATION_CURRENCY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRefundDestinationCurrency(@jakarta.annotation.Nullable String refundDestinationCurrency) {
    this.refundDestinationCurrency = refundDestinationCurrency;
  }

  public PostCryptoReturnPoliciesInput strategy(@jakarta.annotation.Nullable String strategy) {
    
    this.strategy = strategy;
    return this;
  }

  /**
   * The strategy to use for the refund. Can be &#x60;refund_to_sender&#x60; or &#x60;static_address&#x60;. We only support multiple policies for &#x60;static_address&#x60;; different strategies cannot have multiple policies. If multiple &#x60;static_address&#x60; policies exist, the policy that matches both the currency and chain will be used first. If no such policy is found, the policy that matches only the currency will be used instead.
   * @return strategy
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_STRATEGY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getStrategy() {
    return strategy;
  }


  @JsonProperty(value = JSON_PROPERTY_STRATEGY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStrategy(@jakarta.annotation.Nullable String strategy) {
    this.strategy = strategy;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PostCryptoReturnPoliciesInput postCryptoReturnPoliciesInput = (PostCryptoReturnPoliciesInput) o;
    return Objects.equals(this.refundDestinationAddress, postCryptoReturnPoliciesInput.refundDestinationAddress) &&
        Objects.equals(this.refundDestinationBlockchainMemo, postCryptoReturnPoliciesInput.refundDestinationBlockchainMemo) &&
        Objects.equals(this.refundDestinationChain, postCryptoReturnPoliciesInput.refundDestinationChain) &&
        Objects.equals(this.refundDestinationCurrency, postCryptoReturnPoliciesInput.refundDestinationCurrency) &&
        Objects.equals(this.strategy, postCryptoReturnPoliciesInput.strategy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(refundDestinationAddress, refundDestinationBlockchainMemo, refundDestinationChain, refundDestinationCurrency, strategy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PostCryptoReturnPoliciesInput {\n");
    sb.append("    refundDestinationAddress: ").append(toIndentedString(refundDestinationAddress)).append("\n");
    sb.append("    refundDestinationBlockchainMemo: ").append(toIndentedString(refundDestinationBlockchainMemo)).append("\n");
    sb.append("    refundDestinationChain: ").append(toIndentedString(refundDestinationChain)).append("\n");
    sb.append("    refundDestinationCurrency: ").append(toIndentedString(refundDestinationCurrency)).append("\n");
    sb.append("    strategy: ").append(toIndentedString(strategy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

